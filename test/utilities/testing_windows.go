package util

import (
	"encoding/json"
	"errors"
	"fmt"
	"net"

	"github.com/Microsoft/hcsshim/hcn"
	"github.com/Microsoft/windows-container-networking/cni"
	"github.com/Microsoft/windows-container-networking/common"
	"github.com/Microsoft/windows-container-networking/common/core"
	cniSkel "github.com/containernetworking/cni/pkg/skel"
)

var Interface string

func GetDefaultInterface(getipv6 bool) (*net.Interface, *net.IP, *net.IP, error) {
	var foundv4 bool
	var foundv6 bool

	var foundIp *net.IP
	foundIpv6 := &net.IP{}

	foundInterface := net.Interface{}
	ifaces, _ := net.Interfaces()

	if len(ifaces) == 0 {
		return nil, nil, nil, fmt.Errorf("failed to find any network interfaces, unable to proceed with tests")
	}

	i := ifaces[0] // use highest priority network
	foundInterface = i
	Interface = i.Name
	foundv4 = false
	foundv6 = false

	addrs, _ := i.Addrs()
	for _, addr := range addrs {
		ipTemp, _, _ := net.ParseCIDR(addr.String())
		if ipTemp.To4() != nil {

			if !foundv4 {
				foundIp = &ipTemp
				foundv4 = true
			}

		} else {
			if getipv6 &&
				!foundv6 &&
				!ipTemp.IsLinkLocalUnicast() &&
				!ipTemp.IsLoopback() {

				foundIpv6 = &ipTemp
				foundv6 = true
			}
		}

		if foundv4 && foundv6 {
			break
		}
	}
	if foundIp == nil {
		return nil, nil, nil, fmt.Errorf("failed to find interface %s, unable to proceed with tests", Interface)
	}
	return &foundInterface, foundIp, foundIpv6, nil
}

func Getv4Andv6AddressFromIPConfigList(addrs []hcn.IpConfig) (string, string, error) {
	var ipv4addr net.IP
	var ipv6addr net.IP
	var ipv4address string
	var ipv6address string
	var err error

	for _, ipconf := range addrs {
		ip := net.ParseIP(ipconf.IpAddress)

		if ip == nil {
			err = errors.New("Invalid ip address found in ipconfigurations")
			break
		}

		if ip.To4() != nil {
			if ipv4addr == nil {
				ipv4addr = ip
			}

		} else {
			if ipv6addr == nil {
				ipv6addr = ip
			}
		}

		if ipv4addr != nil && ipv6addr != nil {
			break
		}
	}

	if ipv4addr == nil && ipv6addr == nil {
		err = errors.New("No ipv4 or ipv6 address present in ipconfigurations")
	} else if ipv4addr == nil {
		err = errors.New("No ip4 address present in ipconfigurations")
	} else if ipv6addr == nil {
		err = errors.New("No ip6 address present in ipconfigurations")
	} else {
		ipv4address = ipv4addr.String()
		ipv6address = ipv6addr.String()
	}

	return ipv4address, ipv6address, err
}

func CreateArgs(cid string, namespaceID string, cniConfJson []byte) cniSkel.CmdArgs {
	podConf := cni.K8SPodEnvArgs{
		K8S_POD_NAMESPACE: "test-default",
	}
	buffer, err := json.Marshal(podConf)
	if err != nil {
		panic(err)
	}

	args := cniSkel.CmdArgs{
		ContainerID: cid,
		IfName:      Interface,
		Netns:       namespaceID,
		Path:        ".",
		Args:        string(buffer),
		StdinData:   cniConfJson,
	}
	return args
}

func AddCase(args cniSkel.CmdArgs) error {

	config := common.PluginConfig{}

	netPlugin, err := core.NewPlugin(&config)
	if err != nil {
		return err
	}

	err = netPlugin.Start(&config)
	if err != nil {
		return err
	}

	if err := netPlugin.Add(&args); err != nil {
		return fmt.Errorf("Failed to add args %v to net plugin %v: %s", args, netPlugin, err)
	}
	netPlugin.Stop()

	return nil
}

func DelCase(args cniSkel.CmdArgs) error {

	config := common.PluginConfig{}

	netPlugin, err := core.NewPlugin(&config)
	if err != nil {
		return err
	}

	err = netPlugin.Start(&config)
	if err != nil {
		return err
	}

	if err := netPlugin.Delete(&args); err != nil {
		return fmt.Errorf("Failed to delete test case with args %v: %s", args, err)
	}
	netPlugin.Stop()

	return nil
}
